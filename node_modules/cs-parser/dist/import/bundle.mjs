import fs from 'node:fs';

/**
 * A ContextManager can control multiple contexts through the entire parsing
 */
class ContextManager {
	/**
	 * @param {Context} Cx The root context to manage
	 */
	constructor(Cx) {
		Cx.manager = this;
		this._root = Cx;
		this._current = null;
		this._history = [];
		this._buffer = null;
	}

	/**
	 * The root context
	 * @type {Context}
	 * @readonly
	 */
	get root() {
		return this._root
	}

	/**
	 * The current active context
	 * @type {Context}
	 */
	get current() {
		return this._current
	}

	set current(X) {
		if (X && !this._history.includes(X)) {
			if (this._history.length)
				X.prev = this._history[this._history.length - 1];
			this._history.push(X);
		}
		this._current = X;
	}

	/**
	 * An array of contexts which have ever been activated
	 * @type {Context[]}
	 * @readonly
	 */
	get history() {
		return this._history
	}

	set buffer(X) {
		this._buffer = X;
	}

	/**
	 * Feeds a buffer to all the appropriate contexts
	 * depending on the current context
	 * @param {Buffer} Bf
	 */
	feed(Bf) {
		if (this._buffer && this._buffer.length) {
			let bf = this._buffer;
			this._buffer = null;
			this.feed(bf);
		}
		if (Bf.length == 1) {
			this._current.step(Bf);
			this._root.updateState(true);
			return
		}
		if (!Bf.length) throw new Error(`Empty buffer`)
		for (let byte of Bf) {
			let hx = byte.toString(16);
			if (hx.length == 1) hx = '0' + hx; // Zero padding
			this.feed(Buffer.from(hx, 'hex'));
		}
	}
}

/**
 * The base class which provides the implementation of the Composite design pattern.
 * A composite object can form a tree-like structure, the nodes or leaves of which are also composites
 */
class Composite {
	constructor() {
		this._parent = null;
		this._children = [];
	}

	/**
	 * Whether this has parent composite
	 * @type {boolean}
	 * @readonly
	 */
	get hasParent() {
		return this._parent != null
	}

	/**
	 * Whether this has one or more child composites
	 * @type {boolean}
	 * @readonly
	 */
	get hasChild() {
		return this._children.length > 0
	}

	/**
	 * The parent composite
	 * @type {Composite}
	 * @readonly
	 */
	get parent() {
		return this._parent
	}

	/**
	 * The ancestor composites ordered by closest to furthest
	 * @type {Composite[]}
	 * @readonly
	 */
	get ancestors() {
		let r = [];
		let item = this;
		while (item.hasParent) {
			item = item._parent;
			r.push(item);
		}
		return r
	}

	/**
	 * The root of composition
	 * @type {Composite}
	 * @readonly
	 */
	get root() {
		let r = this;
		while (r.hasParent) r = r._parent;
		return r
	}

	/**
	 * The number of child composites
	 * @type {number}
	 * @readonly
	 */
	get length() {
		return this._children.length
	}

	/**
	 * Determines whether the specified composite can be added as a child
	 * @param {Composite} Cp The composite which is about to be added
	 * @return {boolean|string}
	 * `true` if `Cp` is valid. Any type other than `true` means invalid.
	 * If a string is returned, it is shown as an error message in the debug console
	 */
	verifyChild(Cp) {
		return true
	}

	/**
	 * Adds a child composite
	 * @param {Composite} Cp The composite to add as a child
	 * @return {Composite} This
	 */
	addChild(Cp) {
		if (Cp.hasParent) throw new Error('Parent already exists')
		let verified = this.verifyChild(Cp);
		if (verified !== true) {
			console.error(typeof verified == 'string' ? verified : 'Invalid child');
			return this
		}
		Cp._parent = this;
		this._children.push(Cp);
		return this
	}

	/**
	 * Adds multiple child composites
	 * @param {Composite[]} Cps The array of the composites to add
	 * @return {Composite} This
	 */
	addChildren(Cps) {
		for (let item of Cps) this.addChild(item);
		return this
	}

	/**
	 * Performs tree traversal
	 * @param {function} Fn
	 * The callback that receives every descendant composite as the 1st parameter.
	 * If `false` is returned, the traversal will be aborted.
	 * The returned value other than `false` will be passed to the next traversal call of `Fn` as the 2nd parameter
	 * @param {number} Depth=-1
	 * The limit of traversal depth. Negative number means no-limit
	 * @param {mixed} Arg=null
	 * Additinal argument to pass to `Fn` as the 2nd parameter.
	 * @return {boolean}
	 * `true` if the traversal is successfully completed.
	 * `false` if the traversal is aborted
	 */
	traverse(Fn, Depth = -1, Arg = null) {
		let r = true;
		let result = Fn(this, Arg);
		if (result === false || Depth == 0) return !this.hasChild
		for (let item of this._children) {
			if (!item.traverse(Fn, Depth - 1, result) && r) r = false;
		}
		return r
	}

	/**
	 * @ignore
	 */
	[Symbol.iterator]() {
		return this._children[Symbol.iterator]()
	}
}

/**
 * A container that stores parse results
 */
class ResultSet {
	constructor() {
		this._results = [];
	}

	/**
	 * Saves the provided data as a parsing result.
	 * You can pass an array as multiple results
	 * @param {mixed|mixed[]|ResultSet} Result The data to add
	 * @param {boolean} KeepsArray=false
	 * If `true`, stores the result as a single result even if it is an array
	 * @return {ResultSet} This
	 * @chainable
	 */
	add(Result, KeepsArray = false) {
		if (Array.isArray(Result) && !KeepsArray) {
			for (let item of Result) this._results.push(item);
		} else this._results.push(Result);
		return this
	}

	/**
	 * Performs traversal
	 * @param {function} Fn
	 * The callback that receives every single result as the 1st parameter
	 * @param {mixed} Arg=null
	 * Additional argument to pass to `Fn` as the 2nd parameter
	 */
	traverse(Fn, Arg = null) {
		for (let item of this._results) {
			if (item instanceof ResultSet) item.traverse(Fn, Arg);
			else Fn(item, Arg);
		}
	}
}

const // Enums for state
	STANDBY    = Symbol('STANDBY'),
	ACTIVE     = Symbol('ACTIVE'),
	BACKGROUND = Symbol('BACKGROUND'),
	FINISHED   = Symbol('FINISHED'),
	WASTED     = Symbol('WASTED');

/**
 * A parsing context
 * @extends Composite
 */
class Context extends Composite {
	/**
	 * @override
	 * @param {Rule} Rl The rule that determines the behavior of this context
	 * @param {ContextManager} Manager=null The manager that controls this context
	 */
	constructor(Rl, Manager = null) {
		super();
		this._rule = Rl;
		this._manager = Manager;
		this._state = STANDBY;
		this._nextState = null;
		this._results = null;
		this._data = {};
		this._buffer = Buffer.alloc(0);
		this._prev = null;
		this._next = null;
	}

	/**
	 * An enum for {@link Context#state}
	 * which means the context is waiting for being activated
	 * @type {Symbol}
	 * @const
	 */
	static get STANDBY() {
		return STANDBY
	}

	/**
	 * An enum for {@link Context#state}
	 * which means the context is active
	 * @type {Symbol}
	 * @const
	 */
	static get ACTIVE() {
		return ACTIVE
	}

	/**
	 * An enum for {@link Context#state}.
	 * When a sub-context gets activated, the parent context goes this state
	 * @type {Symbol}
	 * @const
	 */
	static get BACKGROUND() {
		return BACKGROUND
	}

	/**
	 * An enum for {@link Context#state}
	 * which means the context has been deactivated
	 * @type {Symbol}
	 * @const
	 */
	static get FINISHED() {
		return FINISHED
	}

	/**
	 * An enum for {@link Context#state}
	 * which means the context has no longer chance of getting activated
	 * @type {Symbol}
	 * @const
	 */
	static get WASTED() {
		return WASTED
	}

	/**
	 * The rule that determines the behavior of this context
	 * @type {Rule}
	 * @readonly
	 */
	get rule() {
		return this._rule
	}

	/**
	 * The manager that is controlling this context
	 * @type {ContextManager}
	 */
	get manager() {
		return this._manager || (this.hasParent ? this.parent.manager : null)
	}

	set manager(X) {
		if (this.hasParent) throw new Error(`Manager of a non-root context cannot be changed`)
		if (this._manager) throw new Error(`Another manager is already set`)
		this._manager = X;
	}

	/**
	 * The current state
	 * @type {Symbol}
	 * @default Context.STANDBY
	 * @readonly
	 */
	get state() {
		return this._state
	}

	/**
	 * The next state which this context is about to change to
	 * @type {Symbol}
	 */
	get nextState() {
		return this._nextState || this._state
	}

	set nextState(X) {
		this._nextState = X;
	}

	/**
	 * The parsing results
	 * @type {ResultSet}
	 * @readonly
	 */
	get results() {
		return this._results
	}

	/**
	 * The data object
	 * @type {mixed}
	 * @default {}
	 */
	get data() {
		return this._data
	}

	set data(X) {
		this._data = X;
	}

	/**
	 * The previous context
	 * @type {Context}
	 */
	get prev() {
		return this._prev
	}

	set prev(X) {
		X._next = this;
		this._prev = X;
	}

	/**
	 * The next context
	 * @type {Context}
	 */
	get next() {
		return this._next
	}

	set next(X) {
		X._prev = this;
		this._next = X;
	}

	/**
	 * @override
	 * @param {Context} Cx The context to verify
	 */
	verifyChild(Cx) {
		if (Cx._manager && Cx._manager !== this.manager)
			throw new Error(`Multiple managers conflicted`)
		return true
	}

	/**
	 * Clears internal reading buffer
	 * @protected
	 */
	clearBuffer() {
		this._buffer = Buffer.alloc(0);
	}

	/**
	 * Populates sub-contexts
	 * @protected
	 */
	populate() {
		if (this._rule.isRecursive) this.addChild(new Context(this._rule));
		for (let item of this._rule) this.addChild(new Context(item));
	}

	/**
	 * Updates the state
	 * @param {boolean} Recursive=false Whether or not to perform recursively
	 */
	updateState(Recursive = false) {
		if (Recursive) {
			for (let item of this._children) item.updateState(Recursive);
		}
		if (!this._nextState) return
		this._state = this._nextState;
		this._nextState = null;

		let manager = this.manager;
		if (manager && this._state == ACTIVE) manager.current = this;
	}

	/**
	 * Removes all the unnecessary children
	 * @param {boolean} Recursive=false Whether or not to perform recursively
	 * @return {Context[]} An array of removed contexts
	 */
	cleanupChildren(Recursive = false) {
		if (!this.hasChild) return
		let children = [];
		let wasted = [];
		for (let item of this._children) {
			if (item.state == WASTED) {
				wasted.push(item);
				continue
			}
			if (Recursive)
				wasted = wasted.concat(item.cleanupChildren(Recursive));
			children.push(item);
		}
		this._children = children;
		return wasted
	}

	/**
	 * Pushes a single byte into the internal reading buffer.
	 * And if the buffer reached at the chunk splitter (default: '\n'),
	 * passes the buffer to `parseChunk()`.
	 * @param {Buffer} Byte The byte to push into the buffer
	 * @return {boolean}
	 * `true` if the buffer reached at the chunk splitter.
	 * Otherwise `false`
	 */
	step(Byte) {
		switch (this.state) {
		case STANDBY:
			break
		case ACTIVE:
			if (
				this._rule.endsWithParent &&
				this.hasParent &&
				this.parent.step(Byte) &&
				this.parent.nextState == FINISHED
			) return true // End with the parent
			// Search a child to activate
			var found = null;
			for (let item of this._children) {
				if (!found && item.step(Byte) && item.nextState == ACTIVE) {
					found = item;
					break // Stop searching
				}
			}
			if (found) {
				this.clearBuffer();
				for (let item of this._children) item.clearBuffer();
				return true
			}
			break
		case BACKGROUND:
			if (
				this._rule.endsWithParent &&
				this.hasParent &&
				this.parent.step(Byte) &&
				this.parent.nextState == FINISHED
			) return true // End with the parent
			break
		default:
			return false
		}
		return this._step(Byte)
	}

	/**
	 * @private
	 * @return {boolean}
	 */
	_step(Byte) {
		this._buffer = Buffer.concat([this._buffer, Byte]);
		let chunks = this._buffer.toString(this._rule.encoding)
			.split(this._rule.splitter);
		if (chunks.length < 2) return false
		if (chunks.length > 2) throw new Error(`Something is going wrong..`)
		this.parseChunk(chunks[0]);
		this.clearBuffer();
		return true
	}

	/**
	 * Applies the rule to a chunk
	 * @param {string} Chunk Chunk to apply the rule
	 */
	parseChunk(Chunk) {
		let manager = this.manager;

		switch (this._state) {
		case STANDBY:
			var starts = this._rule.startsWith(Chunk);
			if (starts || starts === 0) { // Starts
				if (!this.start(Chunk, starts)) manager.buffer = this._buffer;
			}
			break
		case ACTIVE:
			var ends = this._rule.endsWith(Chunk);
			if (ends || ends === 0) { // Ends
				if (!this.end(Chunk, ends)) manager.buffer = this._buffer;
			} else if (!this._rule.parse(this, Chunk))
				manager.buffer = this._buffer;
			break
		case BACKGROUND:
			var ends = this._rule.endsWith(Chunk);
			if (ends || ends === 0) { // Ends
				if (!this.end(Chunk, ends)) manager.buffer = this._buffer;
			}
			break
		}
	}

	/**
	 * Activates this context
	 */
	start(Chunk = null, Arg = null) {
		if (this._state == ACTIVE) {
			console.warn('Already active');
			return false
		}
		this.nextState = ACTIVE;
		this._results = new ResultSet();
		if (this.hasParent) {
			this.parent.nextState = BACKGROUND;
			this.parent.results.add(this._results);
		}
		this.populate();
		return this._rule.init(this, Chunk, Arg)
	}

	/**
	 * Deactivates this context
	 */
	end(Chunk = null, Arg = null) {
		if (this._state == FINISHED) {
			console.warn('Already finished');
			return false
		}
		// End all the sub-contexts
		for (let item of this._children) {
			if (item.state == FINISHED) continue
			item.end();
		}
		switch (this._state) {
		case STANDBY:
			this.nextState = WASTED;
			break
		case ACTIVE:
		case BACKGROUND:
			this.nextState = FINISHED;
			if (this.hasParent) {
				// The parent comes back to active
				this.parent.nextState = ACTIVE;
				this.parent.addChild(new Context(this._rule));
			}
			return this._rule.fin(this, Chunk, Arg)
		}
		return false
	}

	/**
	 * Returns the outlined string for debug
	 * @param {string} Indent=2-spaces The indentation string
	 * @param {number} Level=0 The indentation level
	 * @return {string} The outlined string
	 */
	outline(Indent = '  ', Level = 0) {
		let r = Indent.repeat(Level) + this._rule.express(this);
		for (let item of this._children)
			r += '\n' + item.outline(Indent, Level + 1);
		return r
	}
}

const INHERIT = Symbol('INHERIT');

/**
 * A nestable parsing rule
 * @extends Composite
 */
class Rule extends Composite {
	/**
	 * Creates a rule instance with the options in the specified object.
	 * @param {object} Df=null
	 * The rule definition object that contains the options as its properties.
	 * Definition objects can be **nested**.
	 * A nested definition is interpreted as a **sub-rule**.
	 * The property name for a nested definition must start with `$` (dollar sign)
	 *
	 * ###### Available Options:
	 * @param {string} Df.name
	 * The name of this rule. Only for debug purpose
	 * @param {string|RegExp} Df.from
	 * The pattern that indicates the begining point of this rule.
	 * If the current chunk matched with this pattern,
	 * this rule will be activated, and the new context will start parsing
	 * from the next chunk
	 * @param Df.start
	 * Alias of `from`
	 * @param {string|RegExp} Df.to
	 * The pattern that indicates the end point of this rule.
	 * If the current chunk matched with this pattern,
	 * this rule will be deactivated, and the current context will be finalized
	 * @param Df.end Alias of `to`
	 *
	 * @param {function} Df.onStart
	 * The callback which is called when this rule gets activated.<br>
	 * If this returns `false`, the {@link Parser} will read the current chunk
	 * again
	 * ###### Parameters:
	 * @param {Context} Df.onStart.cx The current context
	 * @param {string} Df.onStart.chunk
	 * The current chunk which has matched with `from`
	 * @param {number|string[]} Df.onStart.matches
	 * If the `from` pattern is a string, the index of the matched string
	 * in the chunk.<br>
	 * If the `from` pattern is a RegExp, the regex matching results array
	 * @param Df.init Alias of `onStart`
	 *
	 * @param {function} Df.onActive
	 * The callback which is called for every single chunk.<br>
	 * If this returns `false`, the {@link Parser} will read the current chunk
	 * again
	 * ###### Parameters:
	 * @param {Context} Df.onActive.cx The current context
	 * @param {string} Df.onActive.chunk The current chunk
	 * @param Df.parse Alias of `onActive`
	 *
	 * @param {function} Df.onEnd
	 * The callback which is called when this rule gets deactivated.
	 * If this returns `false`, the {@link Parser} will read the current chunk
	 * again
	 * ###### Parameters:
	 * @param {Context} Df.onEnd.cx The current context
	 * @param {string} Df.onEnd.chunk
	 * The current chunk which has matched with `to`
	 * @param {number|string[]} Df.onEnd.matches
	 * If the `to` pattern is a string, the index of the matched string
	 * in the chunk.<br>
	 * If the `to` pattern is a RegExp, the regex matching results array
	 * @param Df.fin Alias of `onEnd`
	 *
	 * @param {function} Df.onOutline
	 * **Debug purpose only.**
	 * You can customize the output of {@link Context#outline}
	 * with this callback
	 * ###### Must Return:
	 * The output `string`
	 * ###### Parameters:
	 * @param {Context} Df.onOutline.cx The context to express
	 * @param Df.express Alias of `onOutline`
	 *
	 * @param {object} Df.on
	 * The container for the another aliases of
	 * `onStart`, `onActive`, `onEnd`, `onOutline`
	 * ###### Properties:
	 * @param {function} Df.on.start Alias of `onStart`
	 * @param {function} Df.on.active Alias of `onActive`
	 * @param {function} Df.on.end Alias of `onEnd`
	 * @param {function} Df.on.outline Alias of `onOutline`
	 *
	 * @param {boolean} Df.isRecursive=false Whether this rule is recursive
	 * @param Df.recursive Alias of `isRecursive`
	 * @param Df.recurse Alias of `isRecursive`
	 * @param {boolean} Df.endsWithParent=false
	 * If `true`, the parent rule can end even when this rule is active
	 * @param {string|RegExp} Df.splitter='\n'
	 * The chunk splitter. When the {@link Parser} reached at
	 * the chunk splitter, the substring from the previous chunk splitter
	 * is passed to the rule as a chunk. The default splitter is a line-break
	 * @param {string} Df.encoding=Rule.INHERIT
	 * The encoding to use for converting the buffer to a chunk string.
	 * Falls back to `'utf8'`
	 * @param {object} Df.$any
	 * A sub-rule definition. The property name can be any string
	 * but must start with `$` (dollar sign)
	 */
	constructor(Df = null) {
		super();
		if (!Df) Df = {};
		this._name = Df.name || null;
		this._from = Df.from || Df.start || null;
		this._to = Df.to || Df.end || null;
		this._isRecursive = Df.isRecursive || Df.recursive || Df.recurse || null;
		this._endsWithParent = Df.endsWithParent || null;
		this._splitter = Df.splitter || null;
		this._encoding = Df.encoding || INHERIT;
		this._onStart   = Df.onStart   || (Df.on && Df.on.start)   || Df.init    || null;
		this._onActive  = Df.onActive  || (Df.on && Df.on.active)  || Df.parse   || null;
		this._onEnd     = Df.onEnd     || (Df.on && Df.on.end)     || Df.fin     || null;
		this._onOutline = Df.onOutline || (Df.on && Df.on.outline) || Df.express || null;

		// Sub rules
		for (let i in Df) {
			if (!Df[i]) continue
			let m = i.match(/^\$(.*)$/);
			if (!m) continue
			if (!Df[i].name && m[1]) Df[i].name = m[1];
			this.addChild(new Rule(Df[i]));
		}
	}

	/**
	 * The enum for rule properties,
	 * which means the actual property value inherits from the parent rule
	 * @type {Symbol}
	 * @const
	 */
	static get INHERIT() {
		return INHERIT
	}

	/**
	 * The name of this rule
	 * @type {string}
	 * @default ''
	 */
	get name() {
		return this.get('_name', '')
	}

	set name(X) {
		this.set('_name', X);
	}

	/**
	 * The start pattern
	 * @type {RegExp}
	 * @default null
	 */
	get from() {
		return this.get('_from', null)
	}

	set from(X) {
		this.set('_from', X);
	}

	/**
	 * The start pattern
	 * @deprecated Use {@link Rule#from} instead
	 * @type {RegExp}
	 * @default null
	 */
	get start() {
		console.warn(`rule.start is deprecated. Use rule.from instead`);
		return this.from
	}

	set start(X) {
		console.warn(`rule.start is deprecated. Use rule.from instead`);
		this.from = X;
	}

	/**
	 * The end pattern
	 * @type {RegExp}
	 * @default null
	 */
	get to() {
		return this.get('_to', null)
	}

	set to(X) {
		this.set('_to', X);
	}

	/**
	 * The end pattern
	 * @deprecated Use {@link Rule#to} instead
	 * @type {RegExp}
	 * @default null
	 */
	get end() {
		console.warn(`rule.end is deprecated. Use rule.to instead`);
		return this.to
	}

	set end(X) {
		console.warn(`rule.end is deprecated. Use rule.to instead`);
		this.to = X;
	}

	/**
	 * The event handler which is called when this rule is activated
	 * @type {function}
	 * @default null
	 */
	get onStart() {
		return this.get('_onStart', null)
	}

	set onStart(X) {
		this.set('_onStart', X);
	}

	/**
	 * The event handler which is called every time
	 * the parser reached at {@link Rule#splitter}
	 * @type {function}
	 * @default null
	 */
	get onActive() {
		return this.get('_onActive', null)
	}

	set onActive(X) {
		this.set('_onActive', X);
	}
	/**
	 * The event handler which is called when this rule is deactivated
	 * @type {function}
	 * @default null
	 */
	get onEnd() {
		return this.get('_onEnd', null)
	}

	set onEnd(X) {
		this.set('_onEnd', X);
	}

	/**
	 * **Debug purpose only.**
	 * The callback which runs when {@link Context#outline} is called
	 * @type {function}
	 * @default null
	 */
	get onOutline() {
		return this.get('_onOutline', null)
	}

	set onOutline(X) {
		this.set('_onOutline', X);
	}

	/**
	 * Whether this rule is recursive
	 * @type {boolean}
	 * @default false
	 */
	get isRecursive() {
		return this.get('_isRecursive', false)
	}

	set isRecursive(X) {
		this.set('_isRecursive', X);
	}

	/**
	 * Whether the current context can also be ended by the parent context rule
	 * @type {boolean}
	 * @default false
	 */
	get endsWithParent() {
		return this.get('_endsWithParent', false)
	}

	set endsWithParent(X) {
		this.set('_endsWithParent', X);
	}

	/**
	 * The chunk splitter
	 * @type {string|RegExp}
	 * @default '\n'
	 */
	get splitter() {
		return this.get('_splitter', '\n')
	}

	set splitter(X) {
		this.set('_splitter', X);
	}

	/**
	 * The encoding to decode buffers. Falls back to `'utf8'`
	 * @type {string}
	 * @default Rule.INHERIT
	 */
	get encoding() {
		return this.get('_encoding', 'utf8')
	}

	set encoding(X) {
		this.set('_encoding', X);
	}

	/**
	 * @param {string} Name The name of the property to get
	 * @param {mixed} Fallback The value which the property falls back to
	 * @param {boolean} Inherits=true Whether or not to inherit the parent's value
	 * @return {mixed}
	 * @private
	 */
	get(Name, Fallback, Inherits = true) {
		let prop = this[Name];
		return Inherits && prop == INHERIT ? (
			this.hasParent ?
			this.parent.get(Name, Fallback, Inherits) : Fallback
		) : (prop == null ? Fallback : prop)
	}

	/**
	 * @param {string} Name The name of the property to set
	 * @param {mixed} Value The value to set to the property
	 * @private
	 */
	set(Name, Value) {
		if (this[Name] != null)
			throw new Error(`The property cannot be changed`)
		this[Name] = Value;
	}

	/**
	 * Performs matching the specified chunk with the start pattern
	 * @param {string} Chunk The chunk to match
	 * @return {mixed} The matching result
	 */
	startsWith(Chunk) {
		return Rule.checkEnclosure(Chunk, this.from)
	}

	/**
	 * Performs matching the specified chunk with the end pattern
	 * @param {string} Chunk The chunk to match
	 * @return {mixed} The matching result
	 */
	endsWith(Chunk) {
		return Rule.checkEnclosure(Chunk, this.to)
	}

	/**
	 * @private
	 * @param {string} Chunk
	 * @param {boolean|string|function|RegExp|mixed[]} Cond Condition
	 * @return {mixed}
	 */
	static checkEnclosure(Chunk, Cond) {
		if (!Cond) return false
		switch (typeof Cond) {
		case 'boolean':
			return true
		case 'string':
			let idx = Chunk.indexOf(Cond);
			return idx < 0 ? false : idx
		case 'function':
			return Cond(Chunk)
		}
		if (Cond instanceof RegExp) return Chunk.match(Cond)
		if (Array.isArray(Cond)) {
			for (let item of Cond) {
				let r = Rule.checkEnclosure(Chunk, item);
				if (r) return r
			}
		}
		return false
	}

	/**
	 * Sets an event handler
	 * @param {string} Ev
	 * The event identifier
	 * ###### Available Events:
	 * + `'start'`: Occurs when the current chunk matched with {@link Rule#from}
	 * + `'active'`: While this rule is active, occurs every time the parser reached at {@link Rule#splitter}
	 * + `'end'`: Occurs when the current chunk matched with {@link Rule#to}
	 * + `'outline'`: Occurs when {@link Context#outline} is called. **Debug purpose only**
	 * @param {function} Fn
	 * The event handler.
	 * Returning `false` makes the parser read the current chunk again
	 * ###### Parameters:
	 * @param {Context} Fn.cx The current context
	 * @param {string} Fn.chunk
	 * The current chunk.<br>
	 * **Only for `start`, `active` and `end`**
	 * @param {number|string[]} Fn.matches
	 * The matching result of {@link Rule#from}/{@link Rule#to}.<br>
	 * **Only for `start` and `end` events**
	 */
	on(Ev, Fn) {
		switch (Ev) {
		case 'start':
		case 'active':
		case 'end':
		case 'outline':
			this.set('_on' + Ev[0].toUpperCase() + Ev.slice(1), Fn);
			break
		default:
			throw new Error('No such event')
		}
	}

	/**
	 * Initializes a context
	 * @param {Context} Cx The context to initialize
	 * @param {string} Chunk='' The chunk that matched with the `start` condition
	 * @param {string[]} MatchResult=null The matching result of the `start` condition
	 * @return {boolean}
	 * The result of `init` callback.
	 * If `init` is not specified, `true` will be returned
	 */
	init(Cx, Chunk = '', MatchResult = null) {
		let r = true; // Goes next chunk
		if (this.onStart) {
			r = this.onStart(Cx, Chunk, MatchResult);
			if (typeof r == 'undefined') r = true;
		}
		return r
	}

	/**
	 * Finalizes a context
	 * @param {Context} Cx The context to finalize
	 * @param {string} Chunk='' The chunk that matched with the `end` condition
	 * @param {string[]} MatchResult=null The maching result of the `end` condition
	 * @return {boolean}
	 * Result of `fin` callback.
	 * If `fin` is not specified, `true` will be returned
	 */
	fin(Cx, Chunk = '', MatchResult = null) {
		let r = true; // Goes next chunk
		if (this.onEnd) {
			r = this.onEnd(Cx, Chunk, MatchResult);
			if (typeof r == 'undefined') r = true;
		}
		return r
	}

	/**
	 * Parses a chunk
	 * @param {Context} Cx The current context
	 * @param {string} Chunk='' The chunk to parse
	 * @return {boolean}
	 * The result of `parse` callback.
	 * If `parse` is not specified, `true` will be returned
	 */
	parse(Cx, Chunk = '') {
		let r = true; // Goes next chunk
		if (this.onActive) {
			r = this.onActive(Cx, Chunk);
			if (typeof r == 'undefined') r = true;
		}
		return r
	}

	/**
	 * Expresses a context. **Debug purpose only.**
	 * @param {Context} Cx The context to express
	 * @return {string}
	 */
	express(Cx) {
		return this.onOutline ? this.onOutline(Cx) : (this.name || 'anonymous')
	}
}

/**
 * Context sensitive parser
 */
class Parser {
	/**
	 * @param {object|Rule} Rl=null The root rule
	 */
	constructor(Rl = null) {
		let rule = Rl instanceof Rule ? Rl : new Rule(Rl);
		this._rule = rule.from ? new Rule().addChild(rule) : rule;
		if (!this._rule.name) this._rule.name = 'root';
		this._cm = null;
	}

	/**
	 * Adds a new rule
	 * @param {object|Rule} Rl The rule to add
	 * @return {Rule} The `Rule` object which has peen added
	 */
	addRule(Rl) {
		let rule = Rl instanceof Rule ? Rl : new Rule(Rl);
		this._rule.addChild(rule);
		return rule
	}

	/**
	 * Adds multiple new rules
	 * @param {object[]|Rule[]} Rls An array of the rules to add
	 * @return {Rule[]} An array of `Rule` objects which have been added
	 */
	addRules(Rls) {
		let rules = [];
		for (let item of Rls) rules.push(this.addRule(item));
		return rules
	}

	/**
	 * Parses the data specified as a string or Buffer.
	 * After the parsing completed, returns the root context which contains
	 * all the generated sub-contexts through the entire parsing
	 * @param {string|Buffer} Data The data to be parsed
	 * @return {Context} The root context
	 */
	parse(Data) {
		let cx = new Context(this._rule);
		this.onStart(cx);
		this._cm.feed(Data instanceof Buffer ? Data : Buffer.from(Data));
		this.onComplete(cx);
		return cx
	}

	/**
	 * Parses a file asynchronously
	 * @param {string} Url The file URL
	 * @param {object} Opt Streaming options
	 * @see https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options
	 * @return {Promise}
	 * A Promise that will resolve when the parsing completes.
	 * You can get the root context as the 1st parameter of a callback
	 * which you can pass to `.then()`
	 */
	parseFile(Url, Opt = null) {
		let cx = null;
		let io = fs.createReadStream(Url, Object.assign(Opt || {}, {
			highWaterMark: 1
		}));
		io.on('open', () => {
			try {
				cx = new Context(this._rule);
				this.onStart(cx);
			} catch (e) {
				io.emit('error', e);
			}
		});
		io.on('data', byte => {
			try {
				this._cm.feed(byte);
			} catch (e) {
				io.emit('error', e);
			}
		});
		return new Promise((resolve, reject) => {
			io.on('end', () => {
				this.onComplete(cx);
				resolve(cx);
			});
			io.on('error', function (e) {
				console.error(e);
				io.destroy();
				reject(e);
			});
		})
	}

	/**
	 * @param {Context} Cx The root context
	 * @protected
	 */
	onStart(Cx) {
		this._cm = new ContextManager(Cx);
		Cx.start();
		Cx.updateState(true);
	}

	/**
	 * @param {Context} Cx The finished context
	 * @protected
	 */
	onComplete(Cx) {
		Cx.end();
		Cx.updateState(true);
		Cx.cleanupChildren(true);
	}
}

/**
 * The main API provider
 */
class Main {
	/**
	 * Creates a Parser instance
	 * @param {object|Rule} Rl The parsing rule definition
	 * @return {Parser} A new Parser instance
	 */
	create(Rl) {
		return new Parser(Rl)
	}
	/**
	 * Creates a Rule instance
	 * @param {object} Df The rule definition
	 * @return {Rule} A new Rule instance
	 */
	newRule(Df = null) {
		return new Rule(Df)
	}
}

var main = new Main();

export { main as default };
//# sourceMappingURL=bundle.mjs.map
